<!doctype html>
<meta name=viewport content=width=device-width>
<style>
html { font: 24pt sans-serif; background: #eee; }
input { font: inherit; outline: none; }
input, .right, .wrong { box-sizing: border-box; width: 100% }
input, .right, .wrong { padding: .25rem .5rem; border: .05rem solid rgba(0,0,0,.2) }
.right, .wrong { border-color: transparent }
nav > span { margin-right: .5rem; display: inline-block; width: 2em; height: 2em; text-align: center; border-radius: 2em; background: rgba(0,0,0,.1) }
nav > span > span { display: flex; justify-content: center; align-items: center; width: 100%; height: 100% }
nav > span > span > span { display: flex-item; }
nav .current { background: rgba(0,0,255,.2) }
nav .done { background: rgba(0,128,0,.2) }
nav { position: fixed; top: 0; left: 0; width: 100% }
nav { padding: .5rem; background: #eee; font-size: .8rem }
.wrong span { color: red }
.right { color: green }
.right, .wrong, input { margin-top: .5rem }
body { margin: 1rem; max-width: 20rem; margin: auto; padding: 3rem 1rem }
article { background: white; }
article { border: 1px solid #eee; padding: .5rem; margin: .5rem 0; }
article:last-child { box-shadow: .1rem .1rem rgba(0,0,0,.2); }
</style>
<div id=root></div>
<script src=react.development.js></script>
<script src=react-dom.development.js></script>
<script>
tag = (x, o={}, a=[]) => React.createElement(x, o, ...a)
iota = x => [...Array(x).keys()]
rand = x => Math.floor(Math.random() * x)
pick = x => x[rand(x.length)]
copy = x => JSON.parse(JSON.stringify(x))
trace = x => (console.log(x), x)
last = x => x[x.length - 1]

levels = [iota(7).map(x => ({
  l: 0, q: `<div class=question><img width=200 src=../octo/bug-0${x + 1}-still.svg> <div>Vad är ${x} + 1?</div></div>`, a: x + 1,
})), iota(10).map(x => ({
  l: 1, q: `Vad är ${x} * 2?`, a: x * 2,
})), iota(10).map(x => ({
  l: 1, q: `Vad är ${x}<sup>2</sup>?`, a: x * x,
}))]

save = () => localStorage.setItem("state", JSON.stringify(state))
update = patch => (Object.assign(state, patch), save())

state = localStorage.getItem("state") ? JSON.parse(localStorage.getItem("state")) : {
  problems: [copy(pick(levels[0]))],
  current: 0,
  win: 0,
  c: "",
}

wait = 0
answer = () => {
  wait = 1
  last(state.problems).b = state.c
  update({ c: "" })
  setTimeout(() => {
    if (state.problems.length >= 3 && state.problems.slice(state.problems.length - 3).every(x => x.b == x.a && x.l == last(state.problems).l))
      state.current++
    if (levels[state.current])
      state.problems.push(copy(pick(levels[state.current])))
    else
      update({ win: 1 })
    setTimeout(() => scroll(0, 999999999), 20)
    wait = 0
  }, 300)
}

render = () => tag("div", {}, [
  tag("nav", {},
    iota(levels.length).map(x => tag("span", { className: x == state.current ? "current" : x < state.current ? "done" : ""}, [tag("span", {}, [tag("span", {}, [x + 1])])]))
  ),
  tag("div", {}, state.problems.map(({ q, a, b }, i) => tag("article", {}, [
    tag("div", { dangerouslySetInnerHTML: { __html: q } }),
    b != null && tag("div", {
      className: a == b ? "right" : "wrong"
    }, a == b ? [a] : [tag("span", {}, [`${b} → `]), a]),
    i == state.problems.length - 1 && !wait && tag("form", {
      onSubmit: event => (event.preventDefault(), answer()),
    }, [
      tag("input", {
        autoComplete: "off",
        onChange: event => update({ c: event.target.value }),
        value: state.c,
        autoFocus: true,
        style: { outline: "none" },
      }),
    ])
  ]))),
  !!state.win && "hurra",
])

requestAnimationFrame(function loop() {
  ReactDOM.render(render(), root)
  requestAnimationFrame(loop)
})

</script>
